<html>
  <head>
    <title>Duff Playground</title>
  </head>

  <body>
    <h1 style='text-align: center'>Duff Playground</h1>
    <ul>
      <li><a href = 'audio'>Audio</a></li>
      <li><a href = 'service-worker'>Service Worker</a></li>
    </ul>

    <div id = 'c' style='height: 600px; width: 900px; border-style: solid; border-color: grey; margin-left: auto; margin-right: auto; overflow-y: scroll; overflow-x: auto; word-wrap: break-word; padding: 20px'>




<script>

  originalString = `
    <p>This&nbsp;top&nbsp;level&nbsp;view&nbsp;is&nbsp;by&nbsp;no&nbsp;means&nbsp;a&nbsp;complete&nbsp;description&nbsp;of&nbsp;<strong>project&nbsp;fresh</strong>,&nbsp;it&nbsp;only&nbsp;depicts&nbsp;the&nbsp;component&nbsp;that&nbsp;makes&nbsp;up&nbsp;the&nbsp;system.</p>
    <p>At&nbsp;the&nbsp;top&nbsp;most&nbsp;level&nbsp;lies&nbsp;the&nbsp;USERS,&nbsp;GROUPS&nbsp;and&nbsp;the&nbsp;INVENTORY&nbsp;subsystems.</p>
    <p>&nbsp;</p>
    <p><strong>USERS</strong></p>
    <p>In project fresh, we treat Users as a sub-system so as to make the system as modular as possible..., more on this later. this's is "s'"</p>
    <p>&nbsp;</p>
    <p><strong>GROUPS</strong></p>
    <p>Of&nbsp;course,&nbsp;one&nbsp;of&nbsp;the&nbsp;primary&nbsp;objectives&nbsp;of&nbsp;project&nbsp;fresh&nbsp;is&nbsp;to&nbsp;enable&nbsp;group&nbsp;buying.&nbsp;Thus,&nbsp;it&nbsp;seems&nbsp;logically&nbsp;wise&nbsp;to&nbsp;make&nbsp;creating,&nbsp;modifying,&nbsp;and&nbsp;categorizing&nbsp;groups&nbsp;as&nbsp;easy&nbsp;as&nbsp;possible.</p>
    <p>&nbsp;</p>
    <p><strong>INVENTORY</strong></p>
    <p>As&nbsp;shown&nbsp;in&nbsp;the&nbsp;diagram&nbsp;above,&nbsp;the&nbsp;inventory&nbsp;system&nbsp;is&nbsp;the&nbsp;largest&nbsp;component&nbsp;(&nbsp;or&nbsp;module)&nbsp;in&nbsp;the&nbsp;system.&nbsp;The&nbsp;goal&nbsp;of&nbsp;this&nbsp;inventory&nbsp;system&nbsp;is&nbsp;to&nbsp;know&nbsp;the&nbsp;current&nbsp;inventory&nbsp;levels&nbsp;and&nbsp;to&nbsp;minimize&nbsp;under-stock&nbsp;and&nbsp;overstock&nbsp;situations.&nbsp;The&nbsp;inventory&nbsp;subsystem&nbsp;comprises&nbsp;of&nbsp;</p>
    <ol>
    <li>Aggregation&nbsp;layer&nbsp;(&nbsp;or&nbsp;module)</li>
    <li>Accounting&nbsp;layer&nbsp;and&nbsp;</li>
    <li>Reporting</li>
    </ol>
    <p>&nbsp;</p>
    <p><strong>Aggregation&nbsp;Layer</strong></p>
    <p>The&nbsp;aggregation&nbsp;module&nbsp;will&nbsp;be&nbsp;the&nbsp;<strong>stock&nbsp;taking&nbsp;</strong>component&nbsp;of&nbsp;the&nbsp;system.&nbsp;As&nbsp;such&nbsp;its&nbsp;main&nbsp;objective&nbsp;would&nbsp;be&nbsp;to&nbsp;collection&nbsp;the&nbsp;necessary&nbsp;information&nbsp;about&nbsp;farmer&rsquo;s&nbsp;harvest,&nbsp;be&nbsp;it&nbsp;a&nbsp;pre-harvest&nbsp;(that&nbsp;is&nbsp;,&nbsp;the&nbsp;expected&nbsp;number&nbsp;of&nbsp;crops&nbsp;or&nbsp;products&nbsp;to&nbsp;harvest)&nbsp;or&nbsp;harvested&nbsp;crops&nbsp;or&nbsp;even&nbsp;transit&nbsp;(or&nbsp;exporting)&nbsp;harvest.</p>
    <p>&nbsp;</p>
    <table style="border-collapse: collapse; width: 100%;" border="1">
    <tbody>
    <tr>
    <td style="width: 16.6667%;">jkjk</td>
    <td style="width: 16.6667%;">&nbsp;</td>
    <td style="width: 16.6667%;">;lklk</td>
    <td style="width: 16.6667%;">jhiio</td>
    <td style="width: 16.6667%;">bjk</td>
    <td style="width: 16.6667%;">dsadd</td>
    </tr>
    <tr>
    <td style="width: 16.6667%;">sdkdf</td>
    <td style="width: 16.6667%;">kcclds</td>
    <td style="width: 16.6667%;">&nbsp;</td>
    <td style="width: 16.6667%;">&nbsp;</td>
    <td style="width: 16.6667%;">&nbsp;</td>
    <td style="width: 16.6667%;">&nbsp;</td>
    </tr>
    <tr>
    <td style="width: 16.6667%;">&nbsp;</td>
    <td style="width: 16.6667%;">&nbsp;</td>
    <td style="width: 16.6667%;">&nbsp;</td>
    <td style="width: 16.6667%;">&nbsp;</td>
    <td style="width: 16.6667%;">&nbsp;</td>
    <td style="width: 16.6667%;">&nbsp;</td>
    </tr>
    <tr>
    <td style="width: 16.6667%;">&nbsp;</td>
    <td style="width: 16.6667%;">&nbsp;</td>
    <td style="width: 16.6667%;">&nbsp;</td>
    <td style="width: 16.6667%;">&nbsp;</td>
    <td style="width: 16.6667%;">&nbsp;</td>
    <td style="width: 16.6667%;">&nbsp;</td>
    </tr>
    <tr>
    <td style="width: 16.6667%;">&nbsp;</td>
    <td style="width: 16.6667%;">&nbsp;</td>
    <td style="width: 16.6667%;">&nbsp;</td>
    <td style="width: 16.6667%;">&nbsp;</td>
    <td style="width: 16.6667%;">&nbsp;</td>
    <td style="width: 16.6667%;">&nbsp;</td>
    </tr>
    </tbody>
    </table>
    <p>&nbsp;</p>
    <p><strong>Accounting&nbsp;Layer</strong></p>
    <p>The&nbsp;accounting&nbsp;module&nbsp;will&nbsp;be&nbsp;responsible&nbsp;for&nbsp;all&nbsp;things&nbsp;<strong>payments</strong>,&nbsp;<strong>discounting</strong>&nbsp;and&nbsp;<strong>price&nbsp;indexing</strong>.&nbsp;</p>
    <p>&nbsp;</p>
    <p><strong>Reporting&nbsp;Layer</strong></p>
    <p>The&nbsp;current&nbsp;status&nbsp;of&nbsp;the&nbsp;system&nbsp;as&nbsp;well&nbsp;as&nbsp;feed&nbsp;backs&nbsp;from&nbsp;clients&nbsp;is&nbsp;very&nbsp;important,&nbsp;as&nbsp;such&nbsp;the&nbsp;reporting&nbsp;module&nbsp;will&nbsp;be&nbsp;responsible&nbsp;for&nbsp;<strong>creating</strong>,&nbsp;<strong>scheduling</strong>&nbsp;and&nbsp;<strong>share</strong>&nbsp;reports.</p>`

    let nodes = []
    let selecting = false
    let corrections = []

    let documentContainer = document.getElementById('c')
    documentContainer.innerHTML = originalString

    function stripTags(html) {
      return html.replace(/(<([^>]+)>)/gi, "");
    }

    function decodeHtml(html) {
      let strippedString = stripTags(html) //html.replace(/(<([^>]+)>)/gi, "");
      var txt = document.createElement("textarea");
      txt.innerHTML = strippedString;
      return txt.value;
   }

    /*
      this function is similar to string.replace() function, except that it only replaces the substr that occurs between position i, j
    */
     String.prototype.replaceBetween = function (i, j, substr, newSubstr) {
       let leftStr = this.substr(0, i)
       let str = this.substr(i, substr.length)
       let rightStr = this.substr(j+1)

       // console.log('String1:',i,j)
       // console.log('String2:', leftStr)
       // console.log('String3:', str)
       // console.log('String4:', rightStr)

       // replace str
       str = str.replace(substr, newSubstr)

       // return concatenated string
       return leftStr + str + rightStr
     }

     /*
       given a start and end positions (i and j respectively) in a string, find the nth substring in the string
       in other words, assume that the substr occurs multiple times in a string, find the nth substr that accurs between i, j
       Note: A return value of 0 (zero) means that the substr never occurs in the string
       the function works by sliding the substr through the string to
       1. find a match
       2. count the number of matches
       3. return the number matches so far if position intersects (or returns a zero if no match is found)
     */
     String.prototype.getOffset = function (i, j, substr) {
       let m = 0
       let n = substr.length
       offset = 0
       // console.log('LENGTH:', this, substr.length, substr)
       for(let k = 0; k <= this.length - substr.length; k++) {
         // console.log(m, n, offset, this.substr(m, n), substr)
         if(this.substr(m, n) === substr) offset++
         if(m === i) return offset
         m++
       }
       return 0
     }

    /*
      given an offset (which represents the nth substr in a string), find the starting position of the substr
      the function works by sliding the substr through the string to
      1. find a match
      2. count the number of matches
      3. return the starting position of the substr if number of matches = offset
    */
     String.prototype.getPosition = function (offset, substr) {
       let m = 0
       let n = substr.length
       let p = 0
       let str = stripTags(this)
        // slide the substr through the string
       for(let k = 0; k <= str.length - substr.length; k++) {
         let subs = str.substr(m, n)
         if(subs === substr) p++
         // console.log(m, n,subs.length, offset,p, subs)
         if(p === offset) return m
         m++
       }
       return -1
     }


     String.prototype.replaceWithoutTags = function (offset, substr) {
       let p = 0  // offset counter
       matchFound = false
       tag = false
       partialStr = ''
       matchedStr = ''
       let str = this // main string
       let modifiedStr = '' //

        //
       for(let k = 0, i = 0; k < str.length; k++, i++) {
         // console.log('i:', i)

         if (str[k] === substr[i] && !tag) {  // match found
           matchFound = true
           partialStr += str[k]
         } else if (str[k] === '<') {
             if(str[k+1] === '/') isClosingTag = true
             else isClosingTag = false
             tag = true
             console.log(p, offset-1)
             // is it safe to replace what we have so far?
             if (p === offset - 1) {
               if(partialStr) modifiedStr += generateEventWrapper(partialStr)
               matchedStr += partialStr
               partialStr = ''
             }
             modifiedStr += str[k]
            --i  // move the index back one unit
         } else if (str[k] === '>') {
           tag = false
           modifiedStr += str[k]
           --i  // move the index back one unit
         }
         else { // match not found
           if (!tag) {
             matchFound = false
             matchedStr += partialStr

             if (matchedStr === substr) {
               p++  // increase offset count
             }
             matchedStr = ''

             if (p === offset && i === substr.length) {
               if(partialStr) modifiedStr += generateEventWrapper(partialStr)
             } else {
               modifiedStr += partialStr
             }
             partialStr = ''
             i = -1  // reset the index to the substring

           } else {
             --i
           }
           modifiedStr += str[k]
         }
       }
       // console.log('meeee:', p, offset, substr.length)
       if (p === offset-1) {
         if(partialStr) modifiedStr += generateEventWrapper(partialStr)
       } else {
         modifiedStr += partialStr
       }

       // return modified string
       return modifiedStr
     }

     // console.log(strippedString)
     // console.log(decodeHtml(originalString))

     function getCordinates(e) {
       let cordinates = {
         movementX: e.movementX,
         movementY: e.movementY,
         clientX: e.clientX,
         clientY: e.clientY,
         offsetX: e.offsetX,
         offsetY: e.offsetY,
         pageX: e.pageX,
         pageY: e.pageY,
         screenX: e.screenX,
         screenY: e.screenY,
         region: e.region,
         which: e.which
       }
       return cordinates
     }

     function generateEventWrapper(htmlStr) {
       return `<span style='color: red' class = 'fms-v-2.7'>${htmlStr}</span>`
     }

     function hasWrapperEvent(node) {
       // for (let child of node.children) {
       //   if (child.tagName === 'SPAN' && child.className === 'fms-v-2.7') {
       //     return true // event already added
       //   }
       // }
       if (node.tagName === 'SPAN' && child.className === 'fms-v-2.7') return true
       return false
     }

     function encodeHTMLEntities(txt) {
       let p = document.createElement("p");
       p.textContent = txt;
       return p.innerHTML
     }

     function textNodesUnder(node){
      var all = [];
      for (node=node.firstChild;node;node=node.nextSibling){
        if (node.nodeType==3) all.push(node);
        else all = all.concat(textNodesUnder(node));
      }
      return all;
    }

     documentContainer.onmousedown = (e) => {
       // console.log('MouseDownCordinates',getCordinates(e))
       selecting = true
     }

     documentContainer.onmousemove = (e) => {
       let c = getCordinates(e)
       if(selecting && !nodes.includes(document.elementFromPoint(c.clientX, c.clientY))) {
         if (documentContainer !== document.elementFromPoint(c.clientX, c.clientY))
            nodes.push(document.elementFromPoint(c.clientX, c.clientY))
       }
     }

     documentContainer.onmouseup = (e) => {
        selectedTxt = getSelectedText();
        console.log('sele:', selectedTxt)
        txt = selectedTxt.text
        if (!txt) {
          console.log('No text selected')
        } else {
          console.log('SELECTED:',txt)
          let correction = {
            text: txt,
            startPosition: selectedTxt.startOffset,
            endPosition: selectedTxt.endOffset
          }
          // alert(nodes)

          // remove all child nodes
          for(let i = 0; i < nodes.length; i++) {
            for (let j = 0; j < nodes.length; j++) {
              if(nodes[i].contains(nodes[j]) && nodes[i] !== nodes[j]) {
                // remove node[j]
                nodes.splice(j,1)
                i = 0;
              }
            }
          }

          let nodeCount = 0
          for (node of nodes) {
            nodeCount++ // keep track of number of nodes processed
            if (txt.includes(node.innerText)) { // full selection
              // check for duplicate
              if(hasWrapperEvent(node)) return

              // add event wrapper
              node.innerHTML = generateEventWrapper(node.innerHTML)
              txt = txt.replace(node.innerText, '') // remove processed text from selection
            } else { // half selection
              let str = ''
              let txtNodes = textNodesUnder(node)
              let startIndex = 0
              let endIndex = 0
              let n = 0
              let focusOffset = selectedTxt.focusOffset
              let anchorOffset = selectedTxt.anchorOffset
              let startNode = selectedTxt.startNode
              let endNode = selectedTxt.endNode

              // discard other nodes
              if(nodes.length > 1 && nodeCount === 1) {
                endNode = txtNodes[txtNodes.length - 1]
                focusOffset = txtNodes[txtNodes.length - 1].textContent.length
                str = ''
              }

              if(nodes.length > 1 && nodeCount !== 1) {
                // str = txt.trim()
                startNode = txtNodes[0]
                anchorOffset = 0
              }

              let withinString = false
              for(let i = 0; i < txtNodes.length; i++) {
                if(txtNodes[i] === startNode) {
                  startIndex = anchorOffset + n
                  withinString = true
                }

                if (withinString) str += txtNodes[i].textContent

                if(txtNodes[i] === endNode) {
                  endIndex = focusOffset + n
                  withinString = false
                }
                n += txtNodes[i].textContent.length
              }

              if(nodes.length > 1 && nodeCount === 1) {
                str = str.substr(anchorOffset)
                txt = txt.replace(str, '') // remove processed str from selection
              } else if(nodes.length > 1 && nodeCount !== 1) {
                str = txt.trim()
              } else {
                //str = str.substr(startIndex, txt.length)
                str = txt
              }


              console.log('TEXT NODES:', txtNodes, startIndex, endIndex, node.innerText.length)

              // get the offset from the remaining copied txt
              let offset = node.innerText.getOffset(startIndex, endIndex, str)

              console.log('OFFSET:', offset)
              console.log('TEXT:', txt, str)
              console.log('INNERTEXT:', node.innerText)
              console.log('ACTUALPOSITIONS:', selectedTxt.anchorOffset, selectedTxt.focusOffset)


              // convert txt to HTML entities
              let converted = encodeHTMLEntities(str);

              // get the starting position
              let startPos = node.innerHTML.getPosition(
                  offset,
                  converted
                )
              let endPos = startPos + converted.length - 1

                console.log('POSITION:', startPos, endPos)
                // console.log('INNERHTML:', node.innerHTML)
              // console.log('OUTPUT:', node.innerHTML.replaceWithoutTags(offset, converted))
              node.innerHTML = node.innerHTML.replaceWithoutTags(offset, converted)
            }
          }
          // alert(nodes)
          corrections.push(correction)
        }
        let c = getCordinates(e)
        console.log('MouseUpCordinates',c)
        nodes = []
        selecting = false

      }


      function getSelectedText() {
        var selObj = window.getSelection();
        var selRange = selObj.getRangeAt(0);
        // do stuff with the range
        // console.log('StartContainer:', selRange.startContainer, selRange.startContainer.textContent)
        // console.log('EndContainer:', selRange.endContainer)
        // console.log('ContainerEquals:', selRange.startContainer === selRange.endContainer)
        // console.log('ContainerEquals:', selRange.startContainer.nodeName)
        // console.log(selObj)

        // return selObj.toString()
        let text = selObj.toString()

        return {
          text,
          startOffset: selRange.startOffset,
          endOffset: selRange.endOffset,
          anchorOffset: selObj.anchorOffset,
          focusOffset: selObj.focusOffset,

          startNode: selRange.startContainer,
          endNode: selRange.endContainer
        }
      }

    </script>
  </body>
</html>
